<head>
  <style>
    .log { font-family: "Courier New", Consolas, monospace; font-size: 80%; }
    .test-failed { background-color: #ffaaaa; }
    .test-passed { background-color: #aaffaa; }
  </style>
</head>
<body>
<h3><a href="https://github.com/zachjs/sv2v" target="_blank">zachjs-sv2v</a></h3>
<pre class="test-passed">
description: Tests imported from basejump
should_fail: 0
tags: basejump
incdirs: /home/travis/build/SymbiFlow/sv-tests/third_party/cores/basejump_stl/bsg_noc /home/travis/build/SymbiFlow/sv-tests/third_party/cores/basejump_stl/bsg_misc /home/travis/build/SymbiFlow/sv-tests/third_party/cores/basejump_stl/bsg_cache
top_module: 
type: parsing
mode: parsing
files: <a href="../../../../third_party/cores/basejump_stl/bsg_fpu/bsg_fpu_pkg.v.html" target="file-frame">third_party/cores/basejump_stl/bsg_fpu/bsg_fpu_pkg.v</a> <a href="../../../../third_party/cores/basejump_stl/bsg_cache/bsg_cache_pkg.v.html" target="file-frame">third_party/cores/basejump_stl/bsg_cache/bsg_cache_pkg.v</a> <a href="../../../../third_party/cores/basejump_stl/bsg_misc/bsg_defines.v.html" target="file-frame">third_party/cores/basejump_stl/bsg_misc/bsg_defines.v</a> <a href="../../../../third_party/cores/basejump_stl/bsg_cache/bsg_cache_dma.v.html" target="file-frame">third_party/cores/basejump_stl/bsg_cache/bsg_cache_dma.v</a>
time_elapsed: 0.226s
ram usage: 12352 KB
</pre>
<pre class="log">

module bsg_cache_dma (
	clk_i,
	reset_i,
	dma_cmd_i,
	dma_way_i,
	dma_addr_i,
	done_o,
	snoop_word_o,
	dma_pkt_o,
	dma_pkt_v_o,
	dma_pkt_yumi_i,
	dma_data_i,
	dma_data_v_i,
	dma_data_ready_o,
	dma_data_o,
	dma_data_v_o,
	dma_data_yumi_i,
	data_mem_v_o,
	data_mem_w_o,
	data_mem_addr_o,
	data_mem_w_mask_o,
	data_mem_data_o,
	data_mem_data_i,
	dma_evict_o
);
	localparam [1:0] IDLE = 0;
	localparam [1:0] GET_FILL_DATA = 1;
	localparam [1:0] SEND_EVICT_DATA = 2;
	localparam [3:0] e_dma_nop = 4&#39;b0000;
	localparam [3:0] e_dma_send_fill_addr = 4&#39;b0001;
	localparam [3:0] e_dma_send_evict_addr = 4&#39;b0010;
	localparam [3:0] e_dma_get_fill_data = 4&#39;b0100;
	localparam [3:0] e_dma_send_evict_data = 4&#39;b1000;
	localparam [4:0] LB = 5&#39;b00000;
	localparam [4:0] LH = 5&#39;b00001;
	localparam [4:0] LW = 5&#39;b00010;
	localparam [4:0] LD = 5&#39;b00011;
	localparam [4:0] LBU = 5&#39;b00100;
	localparam [4:0] LHU = 5&#39;b00101;
	localparam [4:0] LWU = 5&#39;b00110;
	localparam [4:0] LDU = 5&#39;b00111;
	localparam [4:0] SB = 5&#39;b01000;
	localparam [4:0] SH = 5&#39;b01001;
	localparam [4:0] SW = 5&#39;b01010;
	localparam [4:0] SD = 5&#39;b01011;
	localparam [4:0] LM = 5&#39;b01100;
	localparam [4:0] SM = 5&#39;b01101;
	localparam [4:0] TAGST = 5&#39;b10000;
	localparam [4:0] TAGFL = 5&#39;b10001;
	localparam [4:0] TAGLV = 5&#39;b10010;
	localparam [4:0] TAGLA = 5&#39;b10011;
	localparam [4:0] AFL = 5&#39;b11000;
	localparam [4:0] AFLINV = 5&#39;b11001;
	localparam [4:0] AINV = 5&#39;b11010;
	localparam [4:0] ALOCK = 5&#39;b11011;
	localparam [4:0] AUNLOCK = 5&#39;b11100;
	parameter addr_width_p = &#34;inv&#34;;
	parameter data_width_p = &#34;inv&#34;;
	parameter block_size_in_words_p = &#34;inv&#34;;
	parameter sets_p = &#34;inv&#34;;
	parameter ways_p = &#34;inv&#34;;
	parameter lg_block_size_in_words_lp = ((block_size_in_words_p == 1) ? 1 : $clog2(block_size_in_words_p));
	parameter lg_sets_lp = ((sets_p == 1) ? 1 : $clog2(sets_p));
	parameter bsg_cache_dma_pkt_width_lp = (1 + addr_width_p);
	parameter data_mask_width_lp = (data_width_p &gt;&gt; 3);
	parameter lg_ways_lp = ((ways_p == 1) ? 1 : $clog2(ways_p));
	parameter debug_p = 0;
	input clk_i;
	input reset_i;
	input wire [3:0] dma_cmd_i;
	input [(lg_ways_lp - 1):0] dma_way_i;
	input [(addr_width_p - 1):0] dma_addr_i;
	output reg done_o;
	output reg [(data_width_p - 1):0] snoop_word_o;
	output wire [(bsg_cache_dma_pkt_width_lp - 1):0] dma_pkt_o;
	output reg dma_pkt_v_o;
	input dma_pkt_yumi_i;
	input [(data_width_p - 1):0] dma_data_i;
	input dma_data_v_i;
	output wire dma_data_ready_o;
	output wire [(data_width_p - 1):0] dma_data_o;
	output wire dma_data_v_o;
	input dma_data_yumi_i;
	output reg data_mem_v_o;
	output reg data_mem_w_o;
	output wire [((lg_sets_lp + lg_block_size_in_words_lp) - 1):0] data_mem_addr_o;
	output wire [(((ways_p - 1) &gt;= 0) ? (((data_mask_width_lp - 1) &gt;= 0) ? (((((ways_p - 1) &gt;= 0) ? ways_p : (2 - ways_p)) * (((data_mask_width_lp - 1) &gt;= 0) ? data_mask_width_lp : (2 - data_mask_width_lp))) + -1) : (((((ways_p - 1) &gt;= 0) ? ways_p : (2 - ways_p)) * ((0 &gt;= (data_mask_width_lp - 1)) ? (2 - data_mask_width_lp) : data_mask_width_lp)) + ((data_mask_width_lp - 1) - 1))) : (((data_mask_width_lp - 1) &gt;= 0) ? ((((0 &gt;= (ways_p - 1)) ? (2 - ways_p) : ways_p) * (((data_mask_width_lp - 1) &gt;= 0) ? data_mask_width_lp : (2 - data_mask_width_lp))) + (((ways_p - 1) * (((data_mask_width_lp - 1) &gt;= 0) ? data_mask_width_lp : (2 - data_mask_width_lp))) - 1)) : ((((0 &gt;= (ways_p - 1)) ? (2 - ways_p) : ways_p) * ((0 &gt;= (data_mask_width_lp - 1)) ? (2 - data_mask_width_lp) : data_mask_width_lp)) + (((data_mask_width_lp - 1) + ((ways_p - 1) * ((0 &gt;= (data_mask_width_lp - 1)) ? (2 - data_mask_width_lp) : data_mask_width_lp))) - 1)))):(((ways_p - 1) &gt;= 0) ? (((data_mask_width_lp - 1) &gt;= 0) ? 0 : (data_mask_width_lp - 1)) : (((data_mask_width_lp - 1) &gt;= 0) ? ((ways_p - 1) * (((data_mask_width_lp - 1) &gt;= 0) ? data_mask_width_lp : (2 - data_mask_width_lp))) : ((data_mask_width_lp - 1) + ((ways_p - 1) * ((0 &gt;= (data_mask_width_lp - 1)) ? (2 - data_mask_width_lp) : data_mask_width_lp)))))] data_mem_w_mask_o;
	output wire [(((ways_p - 1) &gt;= 0) ? (((data_width_p - 1) &gt;= 0) ? (((((ways_p - 1) &gt;= 0) ? ways_p : (2 - ways_p)) * (((data_width_p - 1) &gt;= 0) ? data_width_p : (2 - data_width_p))) + -1) : (((((ways_p - 1) &gt;= 0) ? ways_p : (2 - ways_p)) * ((0 &gt;= (data_width_p - 1)) ? (2 - data_width_p) : data_width_p)) + ((data_width_p - 1) - 1))) : (((data_width_p - 1) &gt;= 0) ? ((((0 &gt;= (ways_p - 1)) ? (2 - ways_p) : ways_p) * (((data_width_p - 1) &gt;= 0) ? data_width_p : (2 - data_width_p))) + (((ways_p - 1) * (((data_width_p - 1) &gt;= 0) ? data_width_p : (2 - data_width_p))) - 1)) : ((((0 &gt;= (ways_p - 1)) ? (2 - ways_p) : ways_p) * ((0 &gt;= (data_width_p - 1)) ? (2 - data_width_p) : data_width_p)) + (((data_width_p - 1) + ((ways_p - 1) * ((0 &gt;= (data_width_p - 1)) ? (2 - data_width_p) : data_width_p))) - 1)))):(((ways_p - 1) &gt;= 0) ? (((data_width_p - 1) &gt;= 0) ? 0 : (data_width_p - 1)) : (((data_width_p - 1) &gt;= 0) ? ((ways_p - 1) * (((data_width_p - 1) &gt;= 0) ? data_width_p : (2 - data_width_p))) : ((data_width_p - 1) + ((ways_p - 1) * ((0 &gt;= (data_width_p - 1)) ? (2 - data_width_p) : data_width_p)))))] data_mem_data_o;
	input [(((ways_p - 1) &gt;= 0) ? (((data_width_p - 1) &gt;= 0) ? (((((ways_p - 1) &gt;= 0) ? ways_p : (2 - ways_p)) * (((data_width_p - 1) &gt;= 0) ? data_width_p : (2 - data_width_p))) + -1) : (((((ways_p - 1) &gt;= 0) ? ways_p : (2 - ways_p)) * ((0 &gt;= (data_width_p - 1)) ? (2 - data_width_p) : data_width_p)) + ((data_width_p - 1) - 1))) : (((data_width_p - 1) &gt;= 0) ? ((((0 &gt;= (ways_p - 1)) ? (2 - ways_p) : ways_p) * (((data_width_p - 1) &gt;= 0) ? data_width_p : (2 - data_width_p))) + (((ways_p - 1) * (((data_width_p - 1) &gt;= 0) ? data_width_p : (2 - data_width_p))) - 1)) : ((((0 &gt;= (ways_p - 1)) ? (2 - ways_p) : ways_p) * ((0 &gt;= (data_width_p - 1)) ? (2 - data_width_p) : data_width_p)) + (((data_width_p - 1) + ((ways_p - 1) * ((0 &gt;= (data_width_p - 1)) ? (2 - data_width_p) : data_width_p))) - 1)))):(((ways_p - 1) &gt;= 0) ? (((data_width_p - 1) &gt;= 0) ? 0 : (data_width_p - 1)) : (((data_width_p - 1) &gt;= 0) ? ((ways_p - 1) * (((data_width_p - 1) &gt;= 0) ? data_width_p : (2 - data_width_p))) : ((data_width_p - 1) + ((ways_p - 1) * ((0 &gt;= (data_width_p - 1)) ? (2 - data_width_p) : data_width_p)))))] data_mem_data_i;
	output reg dma_evict_o;
	localparam counter_width_lp = (((block_size_in_words_p + 1) == 1) ? 1 : $clog2((block_size_in_words_p + 1)));
	localparam byte_offset_width_lp = (((data_width_p &gt;&gt; 3) == 1) ? 1 : $clog2((data_width_p &gt;&gt; 3)));
	reg [1:0] dma_state_n;
	reg [1:0] dma_state_r;
	reg counter_clear;
	reg counter_up;
	wire [(counter_width_lp - 1):0] counter_r;
	bsg_counter_clear_up #(.max_val_p(block_size_in_words_p)) dma_counter(
		.clk_i(clk_i),
		.reset_i(reset_i),
		.clear_i(counter_clear),
		.up_i(counter_up),
		.count_o(counter_r)
	);
	wire counter_fill_max;
	wire counter_evict_max;
	assign counter_fill_max = (counter_r == (block_size_in_words_p - 1));
	assign counter_evict_max = (counter_r == block_size_in_words_p);
	reg [((1 + (((addr_width_p - 1) &gt;= 0) ? addr_width_p : (2 - addr_width_p))) - 1):0] dma_pkt;
	wire in_fifo_v_lo;
	wire [(data_width_p - 1):0] in_fifo_data_lo;
	reg in_fifo_yumi_li;
	bsg_fifo_1r1w_small #(
		.width_p(data_width_p),
		.els_p(block_size_in_words_p)
	) in_fifo(
		.clk_i(clk_i),
		.reset_i(reset_i),
		.data_i(dma_data_i),
		.v_i(dma_data_v_i),
		.ready_o(dma_data_ready_o),
		.v_o(in_fifo_v_lo),
		.data_o(in_fifo_data_lo),
		.yumi_i(in_fifo_yumi_li)
	);
	reg out_fifo_v_li;
	wire out_fifo_ready_lo;
	wire [(data_width_p - 1):0] out_fifo_data_li;
	bsg_two_fifo #(.width_p(data_width_p)) out_fifo(
		.clk_i(clk_i),
		.reset_i(reset_i),
		.v_i(out_fifo_v_li),
		.data_i(out_fifo_data_li),
		.ready_o(out_fifo_ready_lo),
		.v_o(dma_data_v_o),
		.data_o(dma_data_o),
		.yumi_i(dma_data_yumi_i)
	);
	assign dma_pkt_o = dma_pkt;
	wire [(ways_p - 1):0] dma_way_mask;
	bsg_decode #(.num_out_p(ways_p)) dma_way_demux(
		.i(dma_way_i),
		.o(dma_way_mask)
	);
	generate
		genvar i;
		for (i = 0; (i &lt; ways_p); i = (i + 1)) begin
			assign data_mem_w_mask_o[((((data_mask_width_lp - 1) &gt;= 0) ? 0 : (data_mask_width_lp - 1)) + ((((ways_p - 1) &gt;= 0) ? i : (0 - (i - (ways_p - 1)))) * (((data_mask_width_lp - 1) &gt;= 0) ? data_mask_width_lp : (2 - data_mask_width_lp))))+:(((data_mask_width_lp - 1) &gt;= 0) ? data_mask_width_lp : (2 - data_mask_width_lp))] = {data_mask_width_lp {dma_way_mask[i]}};
		end
	endgenerate
	assign data_mem_addr_o = {dma_addr_i[(byte_offset_width_lp + lg_block_size_in_words_lp)+:lg_sets_lp], counter_r[(lg_block_size_in_words_lp - 1):0]};
	assign data_mem_data_o = {ways_p {in_fifo_data_lo}};
	bsg_mux #(
		.width_p(data_width_p),
		.els_p(ways_p)
	) write_data_mux(
		.data_i(data_mem_data_i),
		.sel_i(dma_way_i),
		.data_o(out_fifo_data_li)
	);
	always @(*) begin
		done_o = 1&#39;b0;
		dma_pkt_v_o = 1&#39;b0;
		dma_pkt[(1 + ((((addr_width_p - 1) &gt;= 0) ? addr_width_p : (2 - addr_width_p)) + -1)):(((addr_width_p - 1) &gt;= 0) ? addr_width_p : (2 - addr_width_p))] = 1&#39;b0;
		dma_pkt[((((addr_width_p - 1) &gt;= 0) ? addr_width_p : (2 - addr_width_p)) + -1):0] = {dma_addr_i[(addr_width_p - 1):(byte_offset_width_lp + lg_block_size_in_words_lp)], {(byte_offset_width_lp + lg_block_size_in_words_lp) {1&#39;b0}}};
		data_mem_v_o = 1&#39;b0;
		data_mem_w_o = 1&#39;b0;
		in_fifo_yumi_li = 1&#39;b0;
		dma_state_n = IDLE;
		out_fifo_v_li = 1&#39;b0;
		counter_clear = 1&#39;b0;
		counter_up = 1&#39;b0;
		dma_evict_o = 1&#39;b0;
		case (dma_state_r)
			IDLE: begin
				counter_clear = 1&#39;b0;
				counter_up = 1&#39;b0;
				data_mem_v_o = 1&#39;b0;
				dma_pkt_v_o = 1&#39;b0;
				dma_pkt[(1 + ((((addr_width_p - 1) &gt;= 0) ? addr_width_p : (2 - addr_width_p)) + -1)):(((addr_width_p - 1) &gt;= 0) ? addr_width_p : (2 - addr_width_p))] = 1&#39;b0;
				done_o = 1&#39;b0;
				dma_state_n = IDLE;
				case (dma_cmd_i)
					e_dma_send_fill_addr: begin
						dma_pkt_v_o = 1&#39;b1;
						dma_pkt[(1 + ((((addr_width_p - 1) &gt;= 0) ? addr_width_p : (2 - addr_width_p)) + -1)):(((addr_width_p - 1) &gt;= 0) ? addr_width_p : (2 - addr_width_p))] = 1&#39;b0;
						done_o = dma_pkt_yumi_i;
						dma_state_n = IDLE;
					end
					e_dma_send_evict_addr: begin
						dma_pkt_v_o = 1&#39;b1;
						dma_pkt[(1 + ((((addr_width_p - 1) &gt;= 0) ? addr_width_p : (2 - addr_width_p)) + -1)):(((addr_width_p - 1) &gt;= 0) ? addr_width_p : (2 - addr_width_p))] = 1&#39;b1;
						done_o = dma_pkt_yumi_i;
						dma_state_n = IDLE;
					end
					e_dma_get_fill_data: begin
						counter_clear = 1&#39;b1;
						dma_state_n = GET_FILL_DATA;
					end
					e_dma_send_evict_data: begin
						counter_clear = 1&#39;b1;
						counter_up = 1&#39;b1;
						data_mem_v_o = 1&#39;b1;
						dma_state_n = SEND_EVICT_DATA;
					end
					e_dma_nop:
						;
					default:
						;
				endcase
			end
			GET_FILL_DATA: begin
				dma_state_n = ((counter_fill_max &amp; in_fifo_v_lo) ? IDLE : GET_FILL_DATA);
				data_mem_v_o = in_fifo_v_lo;
				data_mem_w_o = in_fifo_v_lo;
				in_fifo_yumi_li = in_fifo_v_lo;
				counter_up = (in_fifo_v_lo &amp; ~counter_fill_max);
				counter_clear = (in_fifo_v_lo &amp; counter_fill_max);
				done_o = (counter_fill_max &amp; in_fifo_v_lo);
			end
			SEND_EVICT_DATA: begin
				dma_state_n = ((counter_evict_max &amp; out_fifo_ready_lo) ? IDLE : SEND_EVICT_DATA);
				counter_up = (out_fifo_ready_lo &amp; ~counter_evict_max);
				counter_clear = (out_fifo_ready_lo &amp; counter_evict_max);
				out_fifo_v_li = 1&#39;b1;
				data_mem_v_o = (out_fifo_ready_lo &amp; ~counter_evict_max);
				done_o = (counter_evict_max &amp; out_fifo_ready_lo);
				dma_evict_o = 1&#39;b1;
			end
			default: dma_state_n = IDLE;
		endcase
	end
	wire [(lg_block_size_in_words_lp - 1):0] snoop_word_offset;
	wire snoop_word_we;
	assign snoop_word_offset = dma_addr_i[byte_offset_width_lp+:lg_block_size_in_words_lp];
	assign snoop_word_we = (((dma_state_r == GET_FILL_DATA) &amp; (snoop_word_offset == counter_r[(lg_block_size_in_words_lp - 1):0])) &amp; in_fifo_v_lo);
	always @(posedge clk_i)
		if (reset_i)
			dma_state_r &lt;= IDLE;
		else begin
			dma_state_r &lt;= dma_state_n;
			if (snoop_word_we)
				snoop_word_o &lt;= in_fifo_data_lo;
		end
	always @(posedge clk_i)
		if (debug_p)
			if ((dma_pkt_v_o &amp; dma_pkt_yumi_i))
				$display(&#34;&lt;VCACHE&gt; DMA_PKT we:%0d addr:%8h // %8t&#34;, dma_pkt[(1 + ((((addr_width_p - 1) &gt;= 0) ? addr_width_p : (2 - addr_width_p)) + -1)):(((addr_width_p - 1) &gt;= 0) ? addr_width_p : (2 - addr_width_p))], dma_pkt[((((addr_width_p - 1) &gt;= 0) ? addr_width_p : (2 - addr_width_p)) + -1):0], $time);
endmodule

</pre>
</body>